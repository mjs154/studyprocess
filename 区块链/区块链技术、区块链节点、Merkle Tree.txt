区块链技术
	区块链是一种比较特殊的分布式数据库。
	(1)特点:
		(A)去中心化：存在中心点，即类似银行、支付宝、中介等第三方；
		(B)开放性：系统数据是公开透明的；
		(C)自治性：区块链采用基于协商一致的规范和协议(公开透明的算法)；
		(D)信息不可篡改：信息存储到区块链中被永久保存，无法改变；
		(E)匿名性：个人信息都被加密；
	(2)区块结构
		(A)区块头(Head)：记录当前区块的元信息，比如：前一区块的根散列、Merkle树根散列(Hash Tree,存储Hash的一颗树)、时间戳、其他等信息；
		(B)区块主体(Body)：实际数据，交易记录信息；
	(3)工作原理(以记账为例)
		a)拥有第一条账本本记录，该记录包含了交易详细信息；
		b)将第一条记录利用哈希函数(哈希方法略)计算得到一个定长的hash值；
		c)hash值、时间戳、交易记录组成第一个区块；
		d)比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟；
		e)上一个块的Hash值和账本本记录一起作为原始信息进行Hash得到一个定长的hash;
		f)该hash值、时间戳、交易记录组成第2个区块；
		g)...
		以此类推。
	(4)比特币挖矿
		记账工作的过程便是挖矿，节点记账成功，会获取奖励。
		记账时，节点需要的准备工作:
			a)收集广播中还没有被记录账本的原始交易信息；
			b)检查每个交易信息中付款地址有没有足够的余额；
			c)验证交易是否有正确的签名；
			d)把验证通过的交易信息进行打包记录；
			e)添加一个奖励交易：给自己的地址增加12.5比特币。
		工作量证明:
			为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。
			用伪代码表示一下：
			Hash(上一个Hash值，交易记录集) = 456635BCD
			Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD
			我们知道改变Hash的原始信息的任何一部分，Hash值也会随之不断的变化，因此在运算Hash时，不断的改变随机数的值，总可以找的一个随机数使的Hash的结果以若干个0开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。	
		验证
			在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。
			如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。
			网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。
			假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。
		参考https://learnblockchain.cn/2017/11/04/bitcoin-pow/

区块链节点

	区块链节点具备着路由、区块链存储、挖矿和钱包四个模块。
	(1)路由（network routing）
		路由模块承担了发现和维持对等节点的连接、以及广播和接纳新区块的功能实现。理论上，路由模块应该是所有节点都应该具备的模块，否则单一的节点无法参与完整区块链网络的共识和协同。当然也有例外，比如矿池模型中就没有路由模块，但它却十分依赖路由的一些核心协议。
	(2)区块链存储（full blockchain database）：
		区块链存储模块负责保存完整的、最新的区块链副本，本质上就是数据。
	(3)挖矿（miner）
		在比特币的区块链网络上，挖矿模块的任务是通过在某种特殊的硬件设备上执行POW共识算法，以相互竞争的方式创建新的区块。其他平台链上也存在类似的概念，可能基于的硬件或者执行的共识算法不一样等等。
	(4)钱包（wallet）
		钱包模块主要功能是用于管理节点的私钥、资产以及进行交易行为等。
	节点的分类
		参考https://zhuanlan.zhihu.com/p/39350350

Merkle Tree
	Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。
	(1)哈希函数(hash)
		具体参考数据接口-哈希部分。
	(2)Hash List
		在点对点网络中作数据传输的时候，会同时从多个机器上下载数据，而且很多机器可以认为是不稳定或者不可信的。为了校验数据的完整性，更好的办法是把大的文件分割成小的数据块（例如，把分割成2K为单位的数据块）。这样的好处是，如果小块数据在传输过程中损坏了，那么只要重新下载这一快数据就行了，不用重新下载整个文件。
　　		怎么确定小的数据块没有损坏哪？只需要为每个数据块做Hash。BT下载的时候，在下载到真正数据之前，我们会先下载一个Hash列表。那么问题又来了，怎么确定这个Hash列表本事是正确的哪？答案是把每个小块数据的Hash值拼到一起，然后对这个长字符串在作一次Hash运算，这样就得到Hash列表的根Hash(Top Hash or Root Hash)。下载数据的时候，首先从可信的数据源得到正确的根Hash，就可以用它来校验Hash列表了，然后通过校验后的Hash列表校验数据块。
	(3)Merkle Tree
		Merkle Tree可以看做Hash List的泛化（Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree）。
		在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root.
		在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。
　　		Merkle Tree和Hash List的主要区别是，可以直接下载并立即验证Merkle Tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。如果文件非常大，那么Merkle tree和Hash list都很到，但是Merkle tree可以一次下载一个分支，然后立即验证这个分支，如果分支验证通过，就可以下载数据了。而Hash list只有下载整个hash list才能验证。
	(4)Merkle Tree特点
		A)MT是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；
		B)Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH。
		C)非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的。
	(5)Merkle Tree操作
		a)创建
			从叶子节点往前推，首先计算叶子节点的hasn值，叶子节点单个或者两两结合计算其hasn值，得到新节点，以此类推：
		
		b)检索
			略。
		c)更新、插入和删除
			略。
	(6)Merkle Tree的应用
		(1)数字签名
			最初Merkle Tree目的是高效的处理Lamport one-time signatures。 每一个Lamport key只能被用来签名一个消息，但是与Merkle tree结合可以来签名多条Merkle。这种方法成为了一种高效的数字签名框架，即Merkle Signature Scheme。
		(2)P2P网络
			在P2P网络中，Merkle Tree用来确保从其他节点接受的数据块没有损坏且没有被替换，甚至检查其他节点不会欺骗或者发布虚假的块。大家所熟悉的BT下载就是采用了P2P技术来让客户端之间进行数据传输，一来可以加快数据下载速度，二来减轻下载服务器的负担。BT即BitTorrent，是一种中心索引式的P2P文件分分析通信协议。

　　			要进下载必须从中心索引服务器获取一个扩展名为torrent的索引文件（即大家所说的种子），torrent文件包含了要共享文件的信息，包括文件名，大小，文件的Hash信息和一个指向Tracker的URL[8]。Torrent文件中的Hash信息是每一块要下载的文件内容的加密摘要，这些摘要也可运行在下载的时候进行验证。大的torrent文件是Web服务器的瓶颈，而且也不能直接被包含在RSS或gossiped around(用流言传播协议进行传播)。一个相关的问题是大数据块的使用，因为为了保持torrent文件的非常小，那么数据块Hash的数量也得很小，这就意味着每个数据块相对较大。大数据块影响节点之间进行交易的效率，因为只有当大数据块全部下载下来并校验通过后，才能与其他节点进行交易。

　　			就解决上面两个问题是用一个简单的Merkle Tree代替Hash List。设计一个层数足够多的满二叉树，叶节点是数据块的Hash，不足的叶节点用0来代替。上层的节点是其对应孩子节点串联的hash。Hash算法和普通torrent一样采用SHA1。其数据传输过程和第一节中描述的类似。
	参考http://www.cnblogs.com/fengzhiwu/p/5524324.html
